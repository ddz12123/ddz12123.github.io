# let 和 var

```ts
for (var i = 0; i < 3; i++) {
  setTimeout(() => {
    console.log(i); // 输出什么？
  }, 1000);
}
```

输出结果：3 3 3（而非预期的 0 1 2）

原因：
- var 声明的变量属于函数作用域（而非块级作用域），整个 for 循环中只有一个 i 变量。
- 循环同步执行时，i 不断自增到 3 后循环结束。
- setTimeout 是异步回调，1 秒后执行时，访问的是已经变成 3 的全局 i，因此三次输出都是 3


```ts
for (let i = 0; i < 3; i++) {
  setTimeout(() => {
    console.log(i); // 输出什么？
  }, 1000);
}
```

输出结果：0 1 2原因：
- let 声明的变量属于块级作用域，for 循环每次迭代都会创建一个新的 i 变量（绑定当前迭代的值）。
- 每个 setTimeout 回调捕获的是当前迭代的 i（互不干扰），因此 1 秒后分别输出 0、1、2。

## var的变量提升

### 1、声明提升，赋值不提升
用 var 声明的变量，其声明语句会被引擎自动移到当前作用域（函数作用域或全局作用域）的最顶部，但赋值操作仍在原位置执行。
例如：
```ts
console.log(a); // 输出 undefined（而非报错）
var a = 10;
```

### 2、函数作用域内的提升
var 是函数作用域，变量提升仅作用于当前函数内部，而非块级作用域（如 if、for 块）。
例如：
```ts
function fn() {
  console.log(b); // undefined
  if (true) {
    var b = 20; // 声明会被提升到函数顶部
  }
}
fn();
```

