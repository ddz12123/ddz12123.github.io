# JavaScript中的堆与栈

在 JavaScript 开发中，虽然我们很少直接操作内存，但理解堆栈机制对于写出高性能、无内存泄漏的代码至关重要。让我们深入探索 JavaScript 这个动态语言背后的内存世界。


## 栈与堆的区别

在计算机编程中，堆（Heap）和栈（Stack）是两种重要的内存分配方式，主要区别体现在以下几个方面：


### 1. **内存管理方式**
- **栈**：由编译器自动分配和释放，遵循“先进后出（LIFO）”原则。通常用于存储函数参数、局部变量、返回地址等，内存大小在编译期确定（固定或动态但有上限）。
- **堆**：由程序员手动申请（如 `malloc`/`new`）和释放（如 `free`/`delete`），若未手动释放，可能导致内存泄漏。内存大小在运行时动态分配，理论上受限于系统内存。


### 2. **空间大小**
- **栈**：空间较小（通常几MB），超出会导致栈溢出（Stack Overflow），例如递归调用过深。
- **堆**：空间较大（可达GB级别），更适合存储大对象或动态长度的数据（如数组、字符串）。


### 3. **分配效率**
- **栈**：分配效率高，通过栈指针的移动直接完成（类似数据结构中的栈操作），无需复杂的内存管理。
- **堆**：分配效率较低，需要操作系统在空闲内存块中查找合适的空间，可能产生内存碎片。


### 4. **存储内容**
- **栈**：主要存储：
    - 函数的参数值
    - 局部变量（基本类型、对象引用等）
    - 函数返回地址
    - 栈帧信息（上下文数据）
- **堆**：主要存储动态分配的对象（如 `new Object()` 创建的实例）、数组等，对象的引用可能存于栈中。


### 5. **内存碎片**
- **栈**：不会产生碎片，因为内存分配和释放严格遵循顺序，空间连续且自动回收。
- **堆**：频繁分配和释放可能导致内存碎片（零散的空闲内存块无法利用），影响后续分配效率。


### 6. **访问速度**
- **栈**：访问速度快，因为栈内存地址连续，且CPU缓存更易命中。
- **堆**：访问速度较慢，因为内存地址不连续，需要通过指针间接访问，且可能涉及页交换。


## 引用与内存管理

### 原始类型 vs 引用类型

```javascript
// 原始类型 - 按值传递
let a = 10;
let b = a;  // 创建值的副本
b = 20;
console.log(a); // 10 - 原始值不变

// 引用类型 - 按引用传递
let obj1 = { value: 10 };
let obj2 = obj1;  // 复制引用，指向同一个对象
obj2.value = 20;
console.log(obj1.value); // 20 - 原对象被修改
```

### 常见的引用陷阱

```javascript
// 意外的引用共享
const defaultConfig = { theme: 'light', sound: true };
const userConfig = defaultConfig;  // 错误！共享引用
userConfig.theme = 'dark';
console.log(defaultConfig.theme); // 'dark' - 意外修改！

// 正确的做法 - 创建新对象
const safeConfig = { ...defaultConfig };  // 展开运算符
safeConfig.theme = 'dark';
console.log(defaultConfig.theme); // 'light' - 保持原样
```

## 垃圾回收：JavaScript 的内存管家

### 标记清除算法

现代 JavaScript 引擎使用标记清除算法：

```javascript
function garbageCollectionExample() {
    let bigData = new Array(1000000).fill('data');
    
    // 使用完成后...
    bigData = null;  // 显式断开引用，帮助GC
    
    // 或者让变量超出作用域
    {
        let tempData = new Array(500000).fill('temp');
        // 使用 tempData...
    }
    // tempData 自动成为垃圾回收候选
}
```

### 内存泄漏的常见模式

```javascript
// 1. 意外的全局变量
function createLeak() {
    leakedData = new Array(1000000).fill('leak'); // 没有 var/let/const
}

// 2. 遗忘的定时器
function startProcess() {
    const data = loadBigData();
    setInterval(() => {
        process(data); // data 一直被引用，无法回收
    }, 1000);
}

// 3. DOM 引用
function createDOMLeak() {
    const elements = [];
    return function() {
        const element = document.createElement('div');
        document.body.appendChild(element);
        elements.push(element); // 即使从DOM移除，数组仍引用元素
    };
}
```

## 闭包与内存管理

闭包是强大的特性，但需要谨慎使用：

```javascript
function createClosure() {
    const largeData = new Array(100000).fill('data');
    
    return function() {
        // 闭包持有 largeData 的引用，即使外部函数执行完毕
        console.log(largeData.length);
    };
}

const closure = createClosure();
// largeData 无法被回收，因为闭包仍在引用它

// 需要时释放闭包
// closure = null; // 释放引用
```

### 优化闭包内存使用

```javascript
function optimizedClosure() {
    const largeData = new Array(100000).fill('data');
    const neededInfo = largeData.length; // 只提取需要的信息
    
    // 立即释放不需要的大数据引用
    largeData.length = 0;
    
    return function() {
        console.log(neededInfo); // 只保留必要数据
    };
}
```

## 现代 JavaScript 的内存优化技巧

### 1. 对象池模式

```javascript
class ObjectPool {
    constructor(createFn) {
        this.createFn = createFn;
        this.pool = [];
    }
    
    get() {
        return this.pool.length > 0 ? this.pool.pop() : this.createFn();
    }
    
    release(obj) {
        // 重置对象状态
        Object.keys(obj).forEach(key => {
            if (typeof obj[key] === 'object' && obj[key] !== null) {
                obj[key] = null;
            }
        });
        this.pool.push(obj);
    }
}

// 使用对象池
const vectorPool = new ObjectPool(() => ({ x: 0, y: 0, z: 0 }));

const v1 = vectorPool.get();
v1.x = 10; v1.y = 20; v1.z = 30;
// 使用完成后...
vectorPool.release(v1);
```

### 2. 避免内存峰值

```javascript
// 不好的做法：一次性处理大数据
function processAllData(data) {
    return data.map(item => heavyProcessing(item));
}

// 好的做法：分块处理
async function processInChunks(data, chunkSize = 1000) {
    const results = [];
    
    for (let i = 0; i < data.length; i += chunkSize) {
        const chunk = data.slice(i, i + chunkSize);
        results.push(...chunk.map(item => heavyProcessing(item)));
        
        // 给浏览器喘息的机会
        await new Promise(resolve => setTimeout(resolve, 0));
    }
    
    return results;
}
```

### 3. 使用 WeakMap 和 WeakSet

```javascript
// 弱引用，不阻止垃圾回收
const weakCache = new WeakMap();

function cacheComplexCalculation(obj) {
    if (!weakCache.has(obj)) {
        const result = expensiveCalculation(obj);
        weakCache.set(obj, result);
    }
    return weakCache.get(obj);
}

// 当 obj 不再被其他地方引用时，weakCache 中的条目会自动清除
```

## 调试与监控

### Chrome DevTools 内存分析

```javascript
// 手动触发内存快照
function takeMemorySnapshot() {
    if (window.performance && window.performance.memory) {
        console.log('Used JS Heap:', window.performance.memory.usedJSHeapSize);
        console.log('Total JS Heap:', window.performance.memory.totalJSHeapSize);
    }
}

// 监控内存使用
setInterval(takeMemorySnapshot, 5000);
```

### 性能最佳实践

```javascript
// 1. 及时清理事件监听器
class EventManager {
    constructor() {
        this.handlers = new Map();
    }
    
    addListener(element, event, handler) {
        element.addEventListener(event, handler);
        this.handlers.set(handler, { element, event });
    }
    
    removeListener(handler) {
        const { element, event } = this.handlers.get(handler);
        element.removeEventListener(event, handler);
        this.handlers.delete(handler);
    }
    
    cleanup() {
        this.handlers.forEach((info, handler) => {
            info.element.removeEventListener(info.event, handler);
        });
        this.handlers.clear();
    }
}
```

## 框架中的堆栈考虑

### React 示例

```jsx
function MyComponent() {
    // useState 的状态存储在堆中
    const [data, setData] = useState([]);
    
    // useCallback 避免函数重复创建
    const handleClick = useCallback(() => {
        setData(prev => [...prev, 'new item']);
    }, []);
    
    // useMemo 缓存计算结果
    const processedData = useMemo(() => {
        return data.map(item => expensiveTransform(item));
    }, [data]);
    
    return <div onClick={handleClick}>{processedData}</div>;
}
```

