# 事件合成

React 的事件系统采用了**事件合成（SyntheticEvent）** 机制，这是 React 框架中一个重要的设计。下面我来详细解释它的概念、原理和特点。

## 什么是事件合成？

事件合成是 React 实现的一套跨浏览器的事件系统。React 没有使用浏览器的原生事件，而是自己封装了一套事件机制，所有事件都被包装成 SyntheticEvent 对象。

## 事件合成的工作原理

### 1. 事件委托
React 并不是将事件处理器直接绑定到每个 DOM 节点上，而是使用**事件委托**的方式，在 document（React 17 之前）或 React 树的根容器（React 17+）上统一处理所有事件。

```jsx
// React 17 之前：事件委托到 document
document.addEventListener('click', dispatchEvent);

// React 17+：事件委托到 React 树的根容器
rootNode.addEventListener('click', dispatchEvent);
```

### 2. 事件处理流程
```javascript
DOM 事件发生
    ↓
被 React 事件系统捕获
    ↓
创建 SyntheticEvent 对象（包装原生事件）
    ↓
触发对应的 React 事件处理函数
    ↓
事件处理函数执行完毕
    ↓
SyntheticEvent 对象被销毁（属性被置为 null）
```

## SyntheticEvent 对象

SyntheticEvent 是跨浏览器包装器，具有与原生事件相同的接口：

```jsx
function handleClick(e) {
  // e 是 SyntheticEvent 对象
  console.log(e.type);        // "click"
  console.log(e.target);      // 触发事件的 DOM 元素
  console.log(e.currentTarget); // 当前处理事件的 DOM 元素
  
  // 阻止默认行为
  e.preventDefault();
  
  // 阻止冒泡
  e.stopPropagation();
  
  // 原生事件对象
  console.log(e.nativeEvent); // 原生事件
}
```

## React 17 前后的事件系统变化

### React 16 及之前
```javascript
// 所有事件都委托到 document
document.addEventListener('click', handleDocumentClick);
```

### React 17 及之后
```javascript
// 事件委托到 React 应用的根容器
const rootNode = document.getElementById('root');
rootNode.addEventListener('click', handleRootClick);
```

这个变化解决了多个 React 版本共存时的事件冲突问题。

## 事件合成的特点

### 优点

1. **跨浏览器一致性**
```jsx
// 在不同浏览器中表现一致
function handleEvent(e) {
  e.preventDefault();  // 所有浏览器都正常工作
  e.stopPropagation(); // 所有浏览器都正常工作
}
```

2. **事件池机制（React 17 之前）**
```jsx
function handleClick(e) {
  console.log(e.type); // "click"
  
  // 在异步代码中访问事件属性需要特殊处理
  setTimeout(() => {
    // React 17 之前：这里 e.target 可能为 null
    e.persist(); // 保持事件对象不被回收
    console.log(e.target); // 现在可以正常访问
  }, 100);
}
```

3. **自动清理内存**
React 会自动管理事件对象的生命周期，防止内存泄漏。

### 注意事项

1. **异步访问事件对象**
```jsx
function handleClick(e) {
  // 错误：在异步中直接访问
  setTimeout(() => {
    console.log(e.target); // 可能为 null（React 17 之前）
  }, 0);
  
  // 正确：需要持久化（React 17 之前）
  e.persist();
  setTimeout(() => {
    console.log(e.target); // 正常访问
  }, 0);
  
  // 正确：提前保存值
  const target = e.target;
  setTimeout(() => {
    console.log(target); // 正常访问
  }, 0);
}
```

**注意：React 17 移除了事件池机制，不再需要 `e.persist()`**

2. **原生事件访问**
```jsx
function handleClick(e) {
  // 访问原生事件
  const nativeEvent = e.nativeEvent;
  console.log(nativeEvent instanceof MouseEvent); // true
}
```

## 实际使用示例

```jsx
function App() {
  const handleClick = (e) => {
    // SyntheticEvent 对象
    console.log('SyntheticEvent:', e);
    console.log('Native event:', e.nativeEvent);
    
    // 阻止表单提交等默认行为
    e.preventDefault();
    
    // 阻止事件冒泡
    e.stopPropagation();
  };
  
  const handleInput = (e) => {
    // 访问输入值
    console.log('Input value:', e.target.value);
  };
  
  return (
    <div>
      <button onClick={handleClick}>点击我</button>
      <input type="text" onInput={handleInput} />
    </div>
  );
}
```

